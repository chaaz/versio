key: get-cargo-os
value:
  - name: Install Ubuntu dependencies
    if: matrix.os == 'ubuntu-latest'
    run: sudo apt-get update && sudo apt-get install -y libgpg-error-dev libgpgme-dev
  - name: Install MacOS dependencies
    if: matrix.os == 'macos-latest'
    run: brew update; brew install gpgme
  - name: Windows spaces in paths problems in the Year of our Lord 2021 I swear
    if: matrix.os == 'windows-latest'
    run: |
      New-Item -Path "C:\" -Name "pf" -ItemType "directory"
      Copy-Item -Path "C:\Program Files\Git" -Destination "C:\pf" -Recurse
      @("C:\pf\Git\bin", "C:\pf\Git\cmd", "C:\pf\Git\mingw64\bin", "C:\pf\Git\usr\bin") + (Get-Content $env:GITHUB_PATH) | Set-Content $env:GITHUB_PATH
  - name: Install Windows dependencies
    if: matrix.os == 'windows-latest'
    env:
      RUNNER_TEMP: ${{ runner.temp }}
    working-directory: ${{ runner.temp }}
    shell: bash
    # Short version, the choco install only provideds 32-bit dynamic
    # libraries for some reason. We want to try 64-bit static links, so
    # we have to build it ourselves.
    run: |
      export PATH="/c/pf/Git/bin:/c/pf/Git/cmd:/c/pf/Git/mingw64/bin:/c/pf/Git/usr/bin:$PATH"
      pacman --noconfirm -S msys2-devel
      pacman --noconfirm -S msys2-runtime-devel
      curl https://gnupg.org/ftp/gcrypt/libgpg-error/libgpg-error-1.42.tar.bz2 -o libgpg-error-1.42.tar.bz2
      tar -jxf libgpg-error-1.42.tar.bz2
      curl https://gnupg.org/ftp/gcrypt/libassuan/libassuan-2.5.5.tar.bz2 -o libassuan-2.5.5.tar.bz2
      tar -jxf libassuan-2.5.5.tar.bz2
      curl https://gnupg.org/ftp/gcrypt/gpgme/gpgme-1.16.0.tar.bz2 -o gpgme-1.16.0.tar.bz2
      tar -jxf gpgme-1.16.0.tar.bz2
      pushd libgpg-error-1.42
      LDFLAGS="-L/c/pf/Git/usr/lib" CPPFLAGS="-I/c/pf/Git/usr/include" ./configure --enable-static
      make
      make install
      popd
      pushd libassuan-2.5.5
      LDFLAGS="-L/c/pf/Git/usr/lib" CPPFLAGS="-I/c/pf/Git/usr/include" ./configure --enable-static
      make
      make install
      popd
      pushd gpgme-1.16.0
      LDFLAGS="-L/c/pf/Git/usr/lib" CPPFLAGS="-I/c/pf/Git/usr/include" ./configure --enable-static
      make
      make install
      popd
  - name: Get cargo stable
    if: matrix.os != 'windows-latest'
    uses: actions-rs/toolchain@v1
    with:
      toolchain: stable
      components: clippy
  - name: Get cargo nightly
    if: matrix.os != 'windows-latest'
    uses: actions-rs/toolchain@v1
    with:
      toolchain: nightly
      components: rustfmt
  - name: Get Windows cargo stable
    # There's lots of issues here:
    #
    # 1. You can't use a msvc target to build gnupg; the gpg libraries
    #   are built with the GNU toolchain, and are apparently nigh-on
    #   impossible to build in Studio.
    # 2. GnuPG is only available as 32-bit libraries for some reason.
    #   (edit: now availble as 64-bit, since we're building them
    #   ourselves)
    # 3. The 32-bit GNU toolchain included in the Windows runner is
    #   different than the builtin rust installation. That *shouldn't*
    #   be a problem (as of 2020-02, rust is supposed to by favor the
    #   system toolchain), but somehow it is--maybe because it's not as
    #   flexible with 32 bit targets?  Even though we're on the 64 bit
    #   train, we'll still assuming that we have the same problem.
    # 4. The 32-bit GNU toolchain (at least as accessed by rustc/cargo)
    #    (and the 64-bit toolchain?) still seems to be half-baked, and
    #    is missing libraries, including the very important 'ntdll.a'
    # 5. The 32-bit GNU compiler (named something like
    #   `mingw-w64-i686-gcc`) (and the 64-bit compiler
    #   `mingw-w64-x86_64-gcc` ?) is not actually included in the
    #   runner's PATH, making it impossible for cargo to find, and thus
    #   to include its associated libs. You can't even build 32-bit GNU
    #   C programs without explicitly adding it yourself before you
    #   compile. See
    #   https://github.com/actions/virtual-environments/issues/2549
    #
    # Bleh! After sooo many different attempts (some 20 odd different
    # attempts in the runner, and multiple manual tries on various
    # Windows 2019 VMs), it looks like the best way to build this is to
    # use the 32-bit msvc toolchain to cross-compile to the 32-bit gnu
    # target. This was actually recommended by various reputable
    # internet sources (none of which I can find again). Also, we need
    # to ensure that the correct target is selected on Windows builds,
    # and that the cross-compile toolchain can be found. So for Windows
    # builds, we need to
    #
    # - ensure that the stable- or nightly-i686-pc-windows-msvc
    #   cargo toolchain is installed and selected.
    # - ensure that the cross-compile i686-pc-windows-gnu target is
    #   installed.
    # - ensure that the cross-compile toolchain is installed
    #   (`windows-latest` does satisfy this with msys2/mingw)
    # - include "C:\msys64\mingw32\bin" to the PATH before compiling.
    # - use `--release --target i686-pc-windows-gnu` for `cargo build`
    # - remember that this will build to the
    #   `target/i686-pc-windows-gnu/release` directory.
    #
    # Now that we're building the GnuPG Windows libs ourselves, we can
    # safely use the 64-bit (x86_64) toolchain, instead of the 32-bit
    # (i686) toolchain. Everything else remains the same, though.
    if: matrix.os == 'windows-latest'
    uses: actions-rs/toolchain@v1
    with:
      toolchain: stable-x86_64-pc-windows-msvc
      target: x86_64-pc-windows-gnu
      components: clippy
      default: true
  - name: Get Windows cargo nightly
    if: matrix.os == 'windows-latest'
    uses: actions-rs/toolchain@v1
    with:
      toolchain: nightly-x86_64-pc-windows-msvc
      target: x86_64-pc-windows-gnu
      components: rustfmt
  - name: Update Windows target configuration
    if: matrix.os == 'windows-latest'
    run: rustup set default-host x86_64-pc-windows-gnu
  - name: Find paths
    id: cargo-find-paths
    run: 'echo ::set-output name=cargo-lock-glob::"${{ matrix.root }}"/**/Cargo.lock'
  - name: Cache cargo and target
    uses: actions/cache@v1
    with:
      path: |
        ~/.cargo/registry
        ~/.cargo/git
        ${{ matrix.root }}/target
      key: ${{ runner.os }}-cargo-${{ hashFiles(steps.cargo-find-paths.outputs.cargo-lock-glob) }}
